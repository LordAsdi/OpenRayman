#include <data_extractor/dsb/dsb_decompiler.h>
#include <data_extractor/data_decoder.h>
#include <info.h>
#include <cstdint>
#include <unordered_map>

namespace openrayman
{
    bool dsb_decompiler::decompile_dsb(const std::string& source, const std::string& target, dsb_format fmt)
    {
        std::cout << "[openrayman::dsb_decompiler] Reading dsb " << source << " to " << target << std::endl;
        std::ifstream source_stream(source, std::ifstream::in | std::ifstream::binary);
        if(source_stream.is_open())
        {
            source_stream.seekg(0, source_stream.end);
            std::size_t length = source_stream.tellg();
            // Skip header
            source_stream.seekg(4);
            // This will NEVER happen with valid dsbs
            if(length <= 4)
                return false;

            // Reading the whole dsb should be ok, they aren't that big
            char buffer[length - 4];
            source_stream.read(buffer, length - 4);
            data_decoder decoder;
            // This is for documentation
            // data_decoder starts at 0
            // The header is not encoded
            decoder.set_virtual_position(0);
            decoder.decode_array(buffer, length - 4);

            std::ofstream target_stream(target, std::ofstream::out | std::ofstream::binary);
            if(target_stream.is_open())
            {
                if(fmt == dsb_format::openrayman)
                    decompile_sections(buffer, length - 4, target_stream);
                else
                    target_stream.write(buffer, length - 4);
                return true;
            }
        }
        return false;
    }

    struct memorybuf : std::streambuf
    {
        memorybuf(char* begin, char* end)
        {
            setg(begin, begin, end);
        }
    };

    void dsb_decompiler::decompile_sections(char* source, std::size_t source_length, std::ofstream& target)
    {
        target << "# Generated by OpenRayman " << openrayman::version << "\n";
        target << "\n";
        memorybuf streambuf(source, source + source_length);
        std::istream in(&streambuf);
        std::int32_t id;
        in.read((char*)&id, sizeof(std::int32_t));
        while(!in.eof() && id != 0xFFFF)
        {

#define DECOMPILE_SECTION(id, name, function) \
                case (id): \
                { \
                    std::cout << "[openrayman::dsb_decompiler].decompile_sections: decompiling " \
                        << std::hex << "0x" << (id) \
                        << " (decimal " << std::dec << id << ") \"" \
                        << (name) << "\"" << std::endl; \
                    target << "section " << (name) << "\n"; \
                    (function)(in, target); \
                    target << "\n"; \
                    break; \
                }

            switch(id)
            {
                // different sections of the dsb file
                DECOMPILE_SECTION(0x00, "alloc", decompile_alloc);
                DECOMPILE_SECTION(0x1E, "levels", decompile_lvl_list);
                DECOMPILE_SECTION(0x28, "data_directories", decompile_data_directories);
                DECOMPILE_SECTION(0x20, "unknown_blob_0x20", decompile_unknown_blob_0x20);
                DECOMPILE_SECTION(0x46, "vignette", decompile_vignette);
                DECOMPILE_SECTION(0x40, "texture_files", decompile_texture_files);
                DECOMPILE_SECTION(0x6E, "unknown_blob_0x6e", decompile_unknown_blob_0x6e);
                DECOMPILE_SECTION(0x64, "game_options", decompile_game_options);
                DECOMPILE_SECTION(0x5A, "sound_banks", decompile_sound_banks);
                DECOMPILE_SECTION(0x5C, "load_sound_banks", decompile_load_sound_banks);
                default:
                {
                    std::cout << "[openrayman::dsb_decompiler].decompile_sections: Encountered unknown id 0x"
                        << std::hex << id
                        << " (decimal " << std::dec << id << ")"
                        << std::endl;
                    break;
                }
            }
            in.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // this allocates variables?!?!
    void dsb_decompiler::decompile_alloc(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            if(id == 0x10)
            {
                // skip(?, ?);
                target << "    skip(";
                std::int32_t a, b;
                source.read((char*)&a, sizeof(std::int32_t));
                source.read((char*)&b, sizeof(std::int32_t));
                target << std::to_string(a) << ", " << std::to_string(b) << ")\n";
            }
            else
            {
                // alloc(slot, value);
                target << "    alloc(" << std::to_string(id) << ", ";
                std::int32_t a;
                source.read((char*)&a, sizeof(std::int32_t));
                if(a == 0xFFFF)
                    return;
                target << std::to_string(a) << ")\n";
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // Adds levels
    void dsb_decompiler::decompile_lvl_list(std::istream& source, std::ofstream& target)
    {
        std::int32_t num_levels;
        source.read((char*)&num_levels, sizeof(std::int32_t));
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            if(id == 0x1F)
            {
                // add(name);
                target << "    add(\"";
                push_string_with_length_u16(source, target);
                target << "    \")\n";
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // Data directories
    void dsb_decompiler::decompile_data_directories(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            std::string dir = "";

#define TRANSLATE_DATA_ID(id, str) \
                case (id): \
                    dir = (str); \
                    break;

            switch(id)
            {
                TRANSLATE_DATA_ID(41, "dll");
                TRANSLATE_DATA_ID(42, "root");
                TRANSLATE_DATA_ID(43, "world");
                TRANSLATE_DATA_ID(44, "levels");
                TRANSLATE_DATA_ID(45, "sound");
                TRANSLATE_DATA_ID(46, "saves");
                TRANSLATE_DATA_ID(48, "vignette");
                TRANSLATE_DATA_ID(49, "options");
            }
            std::uint16_t str_length;
            source.read((char*)&str_length, sizeof(std::uint16_t));
            char str[str_length];
            source.read(str, str_length);
            std::cout << "[openrayman::dsb_decompiler].decompile_data_directories: " << std::hex << "0x" << id << ": " << str << std::endl;
            // dir(name, path);
            if(dir != "")
                target << "    dir(" << dir << ", \"" << str << "\")\n";
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // TODO: what is this?!?
    // is this ever found?!?!
    void dsb_decompiler::decompile_unknown_blob_0x20(std::istream& source, std::ofstream& target)
    {
        std::cout << "[openrayman::dsb_decompiler].decompile_unknown_blob_0x20: Warning! encountered 0x20" << std::endl;
        std::uint32_t size;
        source.read((char*)&size, sizeof(std::uint32_t));
        target << "    size(" << size << ")\n";
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        std::unordered_map<std::int32_t, int> encountered_ids;
        while(id != 0xFFFF)
        {
            if(encountered_ids.count(id) == 0)
                encountered_ids[id] = 0;
            encountered_ids[id]++;
            source.read((char*)&id, sizeof(std::int32_t));
        }
        for(std::pair<std::int32_t, int> pair : encountered_ids)
            target << "    id_encounter(" << std::hex << "0x" << pair.first << std::dec << ", " << pair.second << ")\n";
    }

    // vignettes are basically loading screens
    void dsb_decompiler::decompile_vignette(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            switch(id)
            {
                case 71:
                case 72:
                {
                    target << "    load_img(\"";
                    push_string_with_length_u16(source, target);
                    target << "\")\n";
                    break;
                }
                case 75:
                {
                    target << "    display()\n";
                    break;
                }
                case 76:
                case 77:
                {
                    std::int32_t tmp;
                    // skip these three
                    // TODO
                    for(int n = 0; n < 3; n++)
                        source.read((char*)&tmp, sizeof(std::int32_t));
                    std::uint8_t r, g, b, a;
                    source.read((char*)&r, 1); source.read((char*)&g, 1); source.read((char*)&b, 1); source.read((char*)&a, 1);
                    target << "    color("
                        << (id == 76 ? "outline" : "inline")
                        << ", " << std::to_string(r)
                        << ", " << std::to_string(g)
                        << ", " << std::to_string(b)
                        << ", " << std::to_string(a)
                        << ")\n";
                    break;
                }
                case 78:
                {
                    std::uint8_t colors[(sizeof(std::uint8_t) * 4) * 4];
                    source.read((char*)colors, (sizeof(std::uint8_t) * 4) * 4);
                    target << "    color(bar";
                    for(int n = 0; n < 4; n++)
                    {
                        target << ", " << std::to_string(colors[(n * 4)])
                            << ", " << std::to_string(colors[(n * 4) + 1])
                            << ", " << std::to_string(colors[(n * 4) + 2])
                            << ", " << std::to_string(colors[(n * 4) + 3]);
                    }
                    target << ")\n";
                    break;
                }
                case 79:
                {
                    std::int32_t values[4];
                    source.read((char*)values, sizeof(std::int32_t) * 4);
                    target << "    create_bar(";
                    for(int n = 0; n < 4; n++)
                        target << (n == 0 ? "" : ", ") << values[n];
                    target << ")\n";
                    break;
                }
                case 80:
                {
                    target << "    add_bar()\n";
                    break;
                }
                case 81:
                {
                    std::int32_t max;
                    source.read((char*)&max, sizeof(std::int32_t));
                    target << "    bar_max(" << max << ")\n";
                    break;
                }
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    void dsb_decompiler::decompile_texture_files(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            if(id == 66)
                target << "    add(textures, \"";
            else
                target << "    add(vignettes, \"";
            push_string_with_length_u16(source, target);
            target << "\")\n";
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    void dsb_decompiler::decompile_unknown_blob_0x6e(std::istream& source, std::ofstream& target)
    {
        std::cout << "[openrayman::dsb_decompiler].decompile_unknown_blob_0x6e: Warning! encountered 0x6e" << std::endl;
        std::uint8_t tmp = 0x00;
        while(tmp != 0xFF)
            source.read((char*)&tmp, 1);
        for(int n = 0; n < 3; n++)
            source.read((char*)&tmp, 1);
    }

    void dsb_decompiler::decompile_game_options(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            switch(id)
            {
                case 0x65:
                {
                    target << "    default_file(\"";
                    push_string_with_length_u16(source, target);
                    target << "\")\n";
                    break;
                }
                case 0x66:
                {
                    target << "    current_file(\"";
                    push_string_with_length_u16(source, target);
                    target << "\")\n";
                    break;
                }
                case 0x67:
                {
                    std::int16_t tmp;
                    source.read((char*)&tmp, sizeof(std::int16_t));
                    break;
                }
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // idk what this is?!?!
    void dsb_decompiler::decompile_sound_banks(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            if(id == 92)
                decompile_load_sound_banks(source, target);
            else
            {
                std::int32_t unknown;
                source.read((char*)&unknown, sizeof(std::int32_t));
                target << "    unknown(" << unknown << ")\n";
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // idk what this is either?!
    void dsb_decompiler::decompile_load_sound_banks(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            if(id == 94)
            {
                std::int32_t bank;
                source.read((char*)&bank, sizeof(std::int32_t));
                target << "    add_bank2(" << bank << ")\n";
            }
            else
            {
                std::int32_t size;
                source.read((char*)&size, sizeof(std::int32_t));
                char bytes[size * 4];
                source.read((char*)&bytes, size * 4);
                target << "    add_bank(";
                for(int n = 0; n < size * 4; n++)
                    target << (n == 0 ? "" : ", ") << std::hex << "0x" << (int)bytes[n];
                target << ")\n";
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    void dsb_decompiler::push_string_null_terminated(std::istream& source, std::ofstream& target)
    {
        char c = 0x00;
        source.read(&c, 1);
        while(c != '\0')
        {
            target << c;
            source.read(&c, 1);
        }
    }

    void dsb_decompiler::push_string_with_length_u16(std::istream& source, std::ofstream& target)
    {
        std::uint16_t length;
        source.read((char*)&length, sizeof(std::uint16_t));
        char str[length];
        source.read(str, length);
        target << str;
    }
}
