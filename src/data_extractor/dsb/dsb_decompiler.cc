#include <data_extractor/dsb/dsb_decompiler.h>
#include <data_extractor/data_decoder.h>
#include <info.h>
#include <cstdint>
#include <unordered_map>

namespace openrayman
{
    bool dsb_decompiler::decompile_dsb(const std::string& source, const std::string& target, dsb_format fmt)
    {
        std::cout << "[openrayman::dsb_decompiler] Reading dsb " << source << " to " << target << std::endl;
        std::ifstream source_stream(source, std::ifstream::in | std::ifstream::binary);
        if(source_stream.is_open())
        {
            source_stream.seekg(0, source_stream.end);
            std::size_t length = source_stream.tellg();
            // Skip header
            source_stream.seekg(4);
            // This will NEVER happen with valid dsbs
            if(length <= 4)
                return false;

            // Reading the whole dsb should be ok, they aren't that big
            char buffer[length - 4];
            source_stream.read(buffer, length - 4);
            data_decoder decoder;
            // This is for documentation
            // data_decoder starts at 0
            // The header is not encoded
            decoder.set_virtual_position(0);
            decoder.decode_array(buffer, length - 4);

            std::ofstream target_stream(target, std::ofstream::out | std::ofstream::binary);
            if(target_stream.is_open())
            {
                if(fmt == dsb_format::openrayman)
                    decompile_sections(buffer, length - 4, target_stream);
                else
                    target_stream.write(buffer, length - 4);
                return true;
            }
        }
        return false;
    }

    struct memorybuf : std::streambuf
    {
        memorybuf(char* begin, char* end)
        {
            setg(begin, begin, end);
        }
    };

    void dsb_decompiler::decompile_sections(char* source, std::size_t source_length, std::ofstream& target)
    {
        target << "# Generated by OpenRayman " << openrayman::version << "\n";
        target << "\n";
        memorybuf streambuf(source, source + source_length);
        std::istream in(&streambuf);
        std::int32_t id;
        in.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {

#define DECOMPILE_SECTION(id, name, function) \
                case (id): \
                    std::cout << "[openrayman::dsb_decompiler].decompile_sections: decompiling " << std::hex << "0x" << (id) << " \"" << (name) << "\"" << std::endl; \
                    target << "section " << (name) << "\n"; \
                    (function)(in, target); \
                    target << "\n"; \
                    break;

            switch(id)
            {
                DECOMPILE_SECTION(0x00, "alloc", decompile_alloc);
                DECOMPILE_SECTION(0x1E, "levels", decompile_lvl_list);
                DECOMPILE_SECTION(0x28, "data_directories", decompile_data_directories);
                DECOMPILE_SECTION(0x20, "unknown_blob_0x20", decompile_unknown_blob_0x20);
                DECOMPILE_SECTION(0x46, "vignette", decompile_vignette);
                case 0x40:
                    break;
                case 0x5A:
                    break;
                case 0x64:
                    break;
                case 0x5C:
                    break;
                case 0x6E:
                    break;
                case 0x78:
                    break;
            }
            in.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // this allocates variables?!?!
    void dsb_decompiler::decompile_alloc(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            if(id == 0x10)
            {
                // skip(?, ?);
                target << "    skip(";
                std::int32_t a, b;
                source.read((char*)&a, sizeof(std::int32_t));
                source.read((char*)&b, sizeof(std::int32_t));
                target << std::to_string(a) << ", " << std::to_string(b) << ")\n";
            }
            else
            {
                // alloc(slot, value);
                target << "    alloc(" << std::to_string(id) << ", ";
                std::int32_t a;
                source.read((char*)&a, sizeof(std::int32_t));
                if(a == 0xFFFF)
                    return;
                target << std::to_string(a) << ")\n";
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // Adds levels
    void dsb_decompiler::decompile_lvl_list(std::istream& source, std::ofstream& target)
    {
        std::int32_t temp;
        source.read((char*)&temp, sizeof(std::int32_t));
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            if(id == 0x1F)
            {
                // add(name);
                target << "    add(\"";
                char c;
                source.read(&c, 1);
                while(c != '\0')
                {
                    target << c;
                    source.read(&c, 1);
                }
                target << "    \")";
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // Data directories
    void dsb_decompiler::decompile_data_directories(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            std::string dir = "";

#define TRANSLATE_DATA_ID(id, str) \
                case (id): \
                    dir = (str); \
                    break;

            switch(id)
            {
                TRANSLATE_DATA_ID(41, "dll");
                TRANSLATE_DATA_ID(42, "root");
                TRANSLATE_DATA_ID(43, "world");
                TRANSLATE_DATA_ID(44, "levels");
                TRANSLATE_DATA_ID(45, "sound");
                TRANSLATE_DATA_ID(46, "saves");
                TRANSLATE_DATA_ID(48, "vignette");
                TRANSLATE_DATA_ID(49, "options");
            }
            std::uint16_t str_length;
            source.read((char*)&str_length, sizeof(std::uint16_t));
            char str[str_length];
            source.read(str, str_length);
            // dir(name, path);
            if(dir != "")
                target << "    dir(" << dir << ", \"" << str << "\")\n";
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }

    // TODO: what is this?!?
    // is this ever found?!?!
    void dsb_decompiler::decompile_unknown_blob_0x20(std::istream& source, std::ofstream& target)
    {
        std::uint32_t size;
        source.read((char*)&size, sizeof(std::uint32_t));
        target << "    size(" << size << ")\n";
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        std::unordered_map<std::int32_t, int> encountered_ids;
        while(id != 0xFFFF)
        {
            if(encountered_ids.count(id) == 0)
                encountered_ids[id] = 0;
            encountered_ids[id]++;
            source.read((char*)&id, sizeof(std::int32_t));
        }
        for(std::pair<std::int32_t, int> pair : encountered_ids)
            target << "    id_encounter(" << std::hex << "0x" << pair.first << std::dec << ", " << pair.second << ")\n";
    }

    // vignettes are basically loading screens
    // TODO: there are some .pgbs in rayman 2 /data
    void dsb_decompiler::decompile_vignette(std::istream& source, std::ofstream& target)
    {
        std::int32_t id;
        source.read((char*)&id, sizeof(std::int32_t));
        while(id != 0xFFFF)
        {
            switch(id)
            {
                case 71:
                {
                    target << "    load_img(\"";
                    char c;
                    source.read(&c, 1);
                    while(c != '\0')
                    {
                        target << c;
                        source.read(&c, 1);
                    }
                    target << "\")\n";
                    break;
                }
                case 72:
                {
                    std::uint16_t length;
                    source.read((char*)&length, sizeof(std::uint16_t));
                    char str[length];
                    source.read(str, length);
                    target << "    load_img(\"" << str << "\")\n";
                    break;
                }
                case 75:
                {
                    target << "    display()\n";
                    break;
                }
                case 76:
                case 77:
                {
                    std::int32_t tmp;
                    // skip these three
                    // TODO
                    for(int n = 0; n < 3; n++)
                        source.read((char*)&tmp, sizeof(std::int32_t));
                    std::uint8_t r, g, b, a;
                    source.read((char*)&r, 1); source.read((char*)&g, 1); source.read((char*)&b, 1); source.read((char*)&a, 1);
                    target << "    color("
                        << (id == 76 ? "outline" : "inline")
                        << ", " << std::to_string(r)
                        << ", " << std::to_string(g)
                        << ", " << std::to_string(b)
                        << ", " << std::to_string(a)
                        << ")\n";
                    break;
                }
                case 78:
                {
                    char tmp[16 * 4];
                    // four pairs of 16?!?!
                    source.read(tmp, 16 * 4);
                    break;
                }
                case 79:
                {
                    char tmp[sizeof(std::int32_t) * 4];
                    // four pairs of int32_t?!?!
                    source.read(tmp, sizeof(std::int32_t) * 4);
                    break;
                }
                case 80:
                {
                    target << "    add_bar()\n";
                    break;
                }
                case 81:
                {
                    std::int32_t max;
                    source.read((char*)&max, sizeof(std::int32_t));
                    target << "    set_bar_max(" << max << ")\n";
                    break;
                }
            }
            source.read((char*)&id, sizeof(std::int32_t));
        }
    }
}
